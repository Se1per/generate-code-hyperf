<?php

declare(strict_types=1);

namespace App\Base\src;

use App\Constants\CodeConstants;
use App\Exception\ApiException;
use Hyperf\Coroutine\Exception\ParallelExecutionException;
use Hyperf\Coroutine\Parallel;
use Hyperf\DbConnection\Db;
use Hyperf\Di\Annotation\Inject;
use Hyperf\Contract\ConfigInterface;
use Psr\Container\ContainerInterface;
use SplQueue;
use App\Base\src\RepositoryPackageInterface;

abstract class RepositoryPackage implements RepositoryPackageInterface
{
    protected $model;
    protected $cache;
    protected array $config;
    protected $user;

    #[Inject]
    protected ?LoggerFactory $loggerFactory;

    #[Inject]
    protected ConfigInterface $configInterface;

    #[Inject]
    protected ContainerInterface $container;

    public function __construct()
    {
        $this->config = $this->configInterface->get('generator');
        $this->cache = $this->config['cache']['enable'] ?? false;
        $this->getModel();
        // return $this;
    }

    public function getModel()
    {
        $eloquentModel = $this->config['general']['model'] . '\\' . str_replace('Repository', '', $this->class_basename(get_class($this)));
        if (!class_exists($eloquentModel)) {
            throw new ApiException(CodeConstants::ERROR, 'æ¨¡å‹ä¸å­˜åœ¨');
        }

        if (!$this->model) {
            $this->model = $this->container->get($eloquentModel);
        }

        return $this->model;
    }

    /**
     * è·å–ç±»çš„åŸºç¡€åç§°
     */
    public function class_basename($class)
    {
        $class = is_object($class) ? get_class($class) : $class;

        return basename(str_replace('\\', '/', $class));
    }

    /**
     * è®°å½•é”™è¯¯æ—¥å¿—ï¼ˆç»Ÿä¸€æ–¹æ³•ï¼‰
     */
    protected function logError(string $method, \Throwable $e, array $context = []): void
    {
        try {

            $logger = $this->loggerFactory->get('sql');

            $logger->error("{$method} å¤±è´¥", array_merge([
                'table' => $this->getModel()->getTable(),
                'method' => $method,
                'error_message' => $e->getMessage(),
                'error_file' => $e->getFile(),
                'error_line' => $e->getLine(),
            ], $context));
        } catch (\Throwable $logError) {
            error_log("æ—¥å¿—è®°å½•å¤±è´¥: " . $logError->getMessage());
        }
    }

    /**
     * è®°å½•ä¿¡æ¯æ—¥å¿—ï¼ˆç»Ÿä¸€æ–¹æ³•ï¼‰
     */
    protected function logInfo(string $method, array $context = []): void
    {
        try {
            $logger = $this->loggerFactory->get('sql');

            $logger->info($method, array_merge([
                'table' => $this->getModel()->getTable(),
            ], $context));
        } catch (\Throwable $e) {
            error_log("æ—¥å¿—è®°å½•å¤±è´¥: " . $e->getMessage());
        }
    }

    /**
     * è®¡ç®—åç¨‹å¹¶å‘æ•°
     */
    protected function calculateParallelCount(
        int $number,
        int $divisor = 2,
        int $max = 50
    ): int {
        $count = intdiv($number, $divisor);
        return min($count, $max);
    }

    /**
     * ä¿å­˜æ•°æ®
     * @param $data
     * @return mixed
     */
    public function saveData($data): mixed
    {
        try {

            $createData = $this->getModel()->create($data);
        } catch (\Throwable $e) {

            $this->logError('saveData', $e, ['data' => $data]);

            throw new ApiException(CodeConstants::ERROR, $e->getMessage());
        }

        return $createData;
    }

    /**
     * æ‰¹é‡æ’å…¥æ•°æ® åç¨‹
     * @param $data
     * @param int $unpack
     * @return array
     */
    public function saveAllData($data, int $unpack = 5): array
    {
        $startTime = microtime(true);

        $dataNum = count($data);

        if ($dataNum < 1) {
            return [false, 'æ•°æ®ä¸èƒ½ä¸ºç©º'];
        }

        if ($dataNum > $unpack) {
            $now = date('Y-m-d H:i:s');
            foreach ($data as &$val) {
                $val['created_at'] = $val['created_at'] ?? $now;
                $val['updated_at'] = $val['updated_at'] ?? $now;
            }
        } else {
            $unpack = $dataNum - 1;
        }

        $chunks = array_chunk($data, $unpack);

        $parallelCount = $this->calculateParallelCount(count($chunks));

        $parallel = new Parallel($parallelCount);

        foreach ($data as $value) {
            $parallel->add(function () use ($value) {
                return $this->getModel()->insert($value);
            });
        }

        try {

            $results = $parallel->wait();

            $endTime = microtime(true);

            $executionTime = $endTime - $startTime;

            $this->logInfo('saveAllData', [
                'count' => count($chunks),
                'records' => $dataNum,
                'executionTime' => $executionTime
            ]);
        } catch (ParallelExecutionException $e) {
            $results = $e->getResults();
            $endTime = microtime(true);
            $executionTime = $endTime - $startTime;

            $error = [
                'count' => count($chunks),
                'executionTime' => $executionTime,
                'error' => $e->getResults(),
                'Throwables' => $e->getThrowables(),
            ];

            $this->logError('saveAllData', $e, ['data' => $data]);

            throw new ApiException(CodeConstants::ERROR, json_encode($error));
        }

        return $results;
    }

    /**
     * æ›´æ–°æ•°æ®
     * @param array $data æ›´æ–°çš„æ•°æ®
     * @param string $key æ›´æ–°çš„é”®å
     * @param bool $returnData æ˜¯å¦è¿”å›æ›´æ–°åçš„æ•°æ®ï¼Œé»˜è®¤ false åªè¿”å› true
     * @return mixed æˆåŠŸè¿”å› true æˆ–æ›´æ–°åçš„å¯¹è±¡ï¼Œå¤±è´¥æŠ›å‡ºå¼‚å¸¸
     */
    public function updateData($data, string $key = 'id', bool $returnData = false): mixed
    {
        if (!isset($data[$key])) {
            throw new ApiException(CodeConstants::ERROR, "ç¼ºå°‘æ›´æ–°é”®: {$key}");
        }

        if (is_array($data[$key])) {
            $transformedData = $this->transformArray($data, $key);
            return $this->updateAllData($transformedData, $key);
        }

        $object = $this->getDataFindBy($key, $data[$key]);

        if (!$object) {
            throw new ApiException(CodeConstants::ERROR, 'æ•°æ®ä¸å­˜åœ¨');
        }

        try {
            $needsUpdate = $this->inspectUpdateData($object, $data);

            if ($needsUpdate) {
                unset($data[$key]);
                $result = $object->update($data);

                // ğŸ”§ æ›´æ–°å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸ï¼ŒåŒ…å«è¯¦ç»†ä¿¡æ¯
                if (!$result) {
                    throw new ApiException(
                        CodeConstants::ERROR,
                        [
                            'error' => 'æ•°æ®æ›´æ–°å¤±è´¥',
                            'model' => get_class($object),
                            'key' => $key,
                            'value' => $data[$key] ?? null,
                            'data' => $data
                        ]
                    );
                }

                // åˆ·æ–°æ¨¡å‹æ•°æ®
                $object->refresh();

                // æ ¹æ®å‚æ•°å†³å®šè¿”å›å†…å®¹
                return $returnData ? $object : true;
            }

            // æ²¡æœ‰éœ€è¦æ›´æ–°çš„å†…å®¹
            return $returnData ? $object : true;
        } catch (ApiException $e) {
            // é‡æ–°æŠ›å‡º ApiExceptionï¼Œä¿æŒé”™è¯¯ä¿¡æ¯å®Œæ•´
            throw $e;
        } catch (\Throwable $e) {
            // è®°å½•æ—¥å¿—å¹¶æŠ›å‡ºå¸¦è¯¦ç»†ä¿¡æ¯çš„å¼‚å¸¸
            $this->logError('updateData', $e, ['data' => $data, 'key' => $key]);

            throw new ApiException(
                CodeConstants::ERROR,
                [
                    'error' => 'æ•°æ®æ›´æ–°å¼‚å¸¸',
                    'message' => $e->getMessage(),
                    'model' => $object ? get_class($object) : 'unknown',
                    'code' => $e->getCode(),
                    'data' => $data
                ]
            );
        }
    }

    /**
     * å•ä¸€æ•°ç»„æ‰¹é‡æ›´æ–°è½¬åŒ–æˆäºŒç»´æ‰¹é‡æ›´æ–°æ•°ç»„æ•°æ®æ ¼å¼
     * @param $input
     * @param string $key
     * @return array
     */
    public function transformArray($input, $key)
    {
        $result = [];

        if (!isset($input[$key]) || !is_array($input[$key])) {
            return $result;
        }

        foreach ($input[$key] as $val) {
            $arr = $input;
            $arr[$key] = $val;
            $result[] = $arr;
        }

        return $result;
    }

    /**
     * æ‰¹é‡æ›´æ–°æ•°æ®(ä¸æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ç›´æ¥æ‰¹é‡æ›´æ–°)
     * @param $data
     * @param string $key
     * @param int $unpack
     * @return array
     */
    public function updateAllData($data, string $key = 'id', int $unpack = 5): array
    {
        $startTime = microtime(true);
        $dataNum = count($data);

        if ($dataNum === 0) {
            return [false, 'æ•°æ®ä¸èƒ½ä¸ºç©º'];
        }

        $parallelCount = $this->calculateParallelCount($dataNum);

        $parallel = new Parallel($parallelCount);

        // æ•°æ®åˆ†å—
        $chunks = $dataNum > $unpack ? array_chunk($data, $unpack) : [$data];

        foreach ($chunks as $chunk) {
            $parallel->add(function () use ($key, $chunk) {
                return $this->updateBatch($chunk, $key);
            });
        }

        try {
            $results = $parallel->wait();
            $endTime = microtime(true);

            $executionTime = $endTime - $startTime;

            $this->logInfo('updateAllData', [
                'chunks' => count($chunks),
                'records' => $dataNum,
                'executionTime' => $executionTime
            ]);

            return [true, $results];
        } catch (ParallelExecutionException $e) {
            $results = $e->getResults();
            $endTime = microtime(true);
            $executionTime = $endTime - $startTime;

            $this->logError('updateAllData', $e, [
                'chunks' => count($chunks),
                'executionTime' => $executionTime,
            ]);

            return [false, $results];
        }
    }

    /**
     * æ‰¹é‡æ›´æ–°åŸºç±»
     * @param array $inputs
     * @param string $where_field
     * @param string $when_field
     * @return mixed
     * $value = [
     * *     [
     * *         'id' => 1,
     * *         'status' => 'active',
     * *         'nickname' => 'Mohammad'
     * *     ],
     * *     [
     * *         'id' => 5,
     * *         'status' => 'deactive',
     * *         'nickname' => 'Ghanbari'
     * *     ],
     * *     [
     * *         'id' => 7,
     * *         'status' => 'deactive',
     * *         'nickname' => 'Ghanbari'
     * *     ]
     * * ];
     */
    public function updateBatch(array $inputs, string $where_field = 'id', string $when_field = 'id'): mixed
    {
        if (empty($inputs)) {
            throw new \InvalidArgumentException('The update data is empty.');
        }

        if (!($where = $this->array_pluck($inputs, $where_field)) || !($when = $this->array_pluck($inputs, $when_field))) {
            throw new \InvalidArgumentException('Missing update condition');
        }
        $when_arr = [];
        // foreach ($inputs as $k => $input) {
        //     $when_val = $input[$when_field] ?? '';
        //     foreach ($input as $key => $value) {
        //         if ($key == $when_field) continue;
        //         $when_arr[$key][] = "when {$when_field} = '{$when_val}' then '{$value}'";
        //     }
        // }
        foreach ($inputs as $k => $input) {
            $when_val = $input[$when_field] ?? '';
            foreach ($input as $key => $value) {
                if ($key == $when_field) continue;
                if (is_array($value) || is_object($value)) {
                    $value = json_encode($value, JSON_UNESCAPED_UNICODE);
                }
                $when_arr[$key][] = "when {$when_field} = '{$when_val}' then '{$value}'";
            }
        }
        foreach ($when_arr as $key => &$item) {
            $item = DB::raw('case ' . implode(' ', $item) . ' end ');
        }

        return $this->model->query(true)->whereIn($where_field, $where)->update($when_arr);
    }

    /**
     * è‡ªå¢æŸå­—æ®µ
     * @param $field
     * @param int $value
     * @return mixed
     */
    public function increment($field, int $value = 1): mixed
    {

        try {
            return  $this->getModel()->increment($field, $value);
        } catch (\Throwable $e) {
            throw new ApiException(CodeConstants::ERROR, $e->getMessage());
        }
    }

    /**
     * è‡ªå‡æŸå­—æ®µ
     * @param $field
     * @param int $value
     * @return mixed
     */
    public function decrement($field, int $value = 1): mixed
    {
        try {

            return $this->getModel()->decrement($field, $value);
        } catch (\Throwable $e) {
            throw new ApiException(CodeConstants::ERROR, $e->getMessage());
        }
    }

    /**
     * åˆ é™¤æ•°æ®
     * @param array $data
     * @param string $key
     * @return bool
     */
    public function deleteData($data, string $key = 'id'): bool
    {
        try {
            $object = $this->getDataFindBy($key, $data[$key]);

            if (!$object) {
                throw new ApiException(CodeConstants::ERROR, 'è¦åˆ é™¤çš„æ•°æ®ä¸å­˜åœ¨');
            }

            $result = $this->getModel()->where($key, $data[$key])->delete();

            if (!$result) {
                throw new ApiException(
                    CodeConstants::ERROR,
                    [
                        'error' => 'æ•°æ®åˆ é™¤å¤±è´¥',
                        'model' => get_class($object),
                        'key' => $key,
                        'value' => $data[$key],
                    ]
                );
            }

            return true;
        } catch (ApiException $e) {
            throw $e;
        } catch (\Throwable $e) {
            $this->logError('deleteData', $e, ['data' => $data, 'key' => $key]);

            throw new ApiException(
                CodeConstants::ERROR,
                [
                    'error' => 'æ•°æ®åˆ é™¤å¼‚å¸¸',
                    'message' => $e->getMessage(),
                    'code' => $e->getCode(),
                    'data' => $data
                ]
            );
        }
    }

    /**
     * è·å–å•æ¡æ•°æ®
     * @param $attribute
     * @param $value
     * @param string $symbol
     * @param array $columns
     * @return mixed
     */
    public function getDataFindBy($attribute, $value, string $symbol = '=', array $columns = array('*')): mixed
    {
        return $this->getModel()->where($attribute, $symbol, $value)->first($columns);
    }

    /**
     * è·å–æ•°æ®é›†
     * @param $attribute
     * @param $value
     * @param string $symbol
     * @param array $columns
     * @return mixed
     */
    public function getDataAllBy($attribute, $value, string $symbol = '=', array $columns = array('*')): mixed
    {
        return $this->getModel()->where($attribute, $symbol, $value)->get($columns);
    }

    /**
     * è·å–æ¸¸æ ‡å¯¹è±¡
     * @return mixed
     */
    public function getCursorDataAll(): mixed
    {
        return $this->getModel()->cursor();
    }

    /**
     * è·å–æ•°æ®é›†
     * @param $attribute
     * @param array $value
     * @param array $columns
     * @return mixed
     */
    public function getDataInBy($attribute, array $value, array $columns = array('*')): mixed
    {
        return $this->getModel()->whereIn($attribute, $value)->get($columns);
    }

    /**
     * æ‰§è¡Œæ•°æ®å±‚æ„é€ 
     * @param array $data
     * @param $model
     * @return mixed
     */
    public function getCount(array $data = [], $model = null): mixed
    {
        return $this->runningSql($data, 'count', $model);
    }

    /**
     * ç»Ÿä¸€æ‰§è¡Œsql
     * @param array $data
     * @param string|array $get
     * @param $model
     * @param bool $cache
     * @param bool $needToArray
     * @return mixed
     */
    public function getData(
        array $data = [],
        string|array $get = 'get',
        mixed $model = null,
        bool $cache = false,
        bool $needToArray = false
    ): mixed {
        if ($cache && !is_object($model) && $this->cache) {
            $key = $this->getModel()->getKeyName();
            switch ($get) {
                case 'find':
                case 'first':
                    $ids = $this->runningSql($data, ['pluck' => $key], $model, true);
                    return $this->findFromCache(array_shift($ids));
                default:
                case 'get':
                    $ids = $this->runningSql($data, ['pluck' => $key], $model, true);
                    return $this->findManyFromCache($ids);
            }
        }

        return $this->runningSql($data, $get, $model, $needToArray);
    }

    /**
     * æ‰§è¡Œåº•å±‚sql
     * @param $data
     * @param bool $needToArray
     * @param string $get
     * @param $object
     * @return mixed
     */
    public function runningSql(
        array $data,
        string|array $get = 'get',
        mixed $object = null,
        bool $needToArray = false,
    ): mixed {
        if (!$object) {
            $object = $this->getModel();
        }

        foreach ($data as $k => $val) {
            if ($get == 'count' && $k == 'skip') continue;

            if ($k == 'with') {
                $object = $object->$k($val);
                continue;
            }

            if ($k == 'skip') {
                $object = $object->skip($val['page'])->take($val['limit']);
                continue;
            }

            switch ($this->array_depth($val)) {
                case 1;
                    $object = $object->$k(...$val);
                    break;
                case 2;
                    if ($k == 'whereIn' || $k == 'whereBetween') {
                        $object = $object->$k(...$val);
                    } else if ($k == 'where' || $k == 'orderBy') {
                        foreach ($val as $vv) {
                            $object = $object->$k(...$vv);
                        }
                    } else {
                        $object = $object->$k($val);
                    }
                    break;
                case 3;
                    foreach ($val as $vv) {
                        $object = $object->$k(...$vv);
                    }
                    break;
                default:
                    $object = $object->$k($val);
                    break;
            }
        }

        switch ($get) {
            case 'chunk':
            case 'cursor':
                return $object;
        }

        if (is_array($get)) {
            $key = key($get);
            $list = $object->$key($get[$key]);
            $get = $key;
        } else {
            $list = $object->$get();
        }

        switch ($get) {
            case 'pluck':
            case 'first':
                if ($list && $needToArray) $list = $list->toArray();
                break;
            case 'get':
                if ($needToArray) $list = $list->toArray();
                break;
        }

        return $list;
    }

    /**
     * æ‰¹é‡æŸ¥è¯¢ç¼“å­˜
     * @param $ids
     * @return mixed
     */
    public function findManyFromCache($ids)
    {
        return $this->getModel()->findManyFromCache($ids);
    }

    /**
     * æŸ¥è¯¢å•ä¸ªç¼“å­˜
     * @param $ids
     * @return mixed
     */
    public function findFromCache($ids)
    {
        return $this->getModel()->findFromCache($ids);
    }

    /**
     * åˆ¤æ–­æ•°æ®æ˜¯å¦äºŒç»´æˆ–è€…ä¸€ç»´æ•°ç»„
     * @param $array
     * @return int
     */
    public function array_depth($array): int
    {
        if (!is_array($array)) {
            return 0;
        }

        $depth = 1;
        $queue = new SplQueue();
        array_walk($array, function ($element) use ($queue) {
            if (is_array($element)) {
                $queue->enqueue($element);
            }
        });

        while (!$queue->isEmpty()) {
            $currentLevelSize = $queue->count();
            for ($i = 0; $i < $currentLevelSize; $i++) {
                $current = $queue->dequeue();
                array_walk($current, function ($element) use ($queue) {
                    if (is_array($element)) {
                        $queue->enqueue($element);
                    }
                });
            }
            $depth++;
        }

        return $depth;
    }

    public function array_pluck(array $array, string $key)
    {
        return array_map(function ($item) use ($key) {
            return $item[$key] ?? null;
        }, $array);
    }

    /**
     * åˆ¤æ–­æ•°æ®æ˜¯å¦éœ€è¦æ›´æ–°
     * @param $object
     * @param $data
     * @return bool
     */
    public function inspectUpdateData($object, $data): bool
    {
        // æ ‡è¯†æ˜¯å¦éœ€è¦æ›´æ–°
        $needsUpdate = false;

        // éå†å®¢æˆ·ç«¯ä¼ æ¥çš„æ•°æ®
        foreach ($data as $key => $value) {
            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¯¥å­—æ®µä¸”ä¸æ•°æ®åº“ä¸­çš„å€¼ä¸ä¸€è‡´
            if (array_key_exists($key, $object->getAttributes()) && $object->$key != $value) {
                $needsUpdate = true; // æ ‡è®°éœ€è¦æ›´æ–°
            }
        }

        return $needsUpdate;
    }
}
